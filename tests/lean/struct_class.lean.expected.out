alternative : (Type → Type) → Type
applicative : (Type → Type) → Type
decidable : Prop → Type₁
functor : (Type → Type) → Type
has_add : Type → Type
has_andthen : Type → Type
has_append : Type → Type
has_coe : Type → Type → Type
has_coe_t : Type → Type → Type
has_coe_to_fun : Type → Type
has_coe_to_sort : Type → Type
has_div : Type → Type
has_dvd : Type → Type
has_inv : Type → Type
has_le : Type → Type
has_lift : Type → Type → Type
has_lift_t : Type → Type → Type
has_lt : Type → Type
has_mod : Type → Type
has_mul : Type → Type
has_neg : Type → Type
has_one : Type → Type
has_ordering : Type → Type
has_sizeof : Type → Type
has_sub : Type → Type
has_to_format : Type → Type
has_to_pexpr : Type → Type
has_to_string : Type → Type
has_to_tactic_format : Type → Type
has_zero : Type → Type
inhabited : Type → Type
is_associative : Π {A}, (A → A → A) → Type₁
monad : (Type → Type) → Type
nonempty : Type → Prop
point : Type → Type → Type
setoid : Type → Type
subsingleton : Type → Prop
alternative : (Type → Type) → Type
applicative : (Type → Type) → Type
decidable : Prop → Type₁
functor : (Type → Type) → Type
has_add : Type → Type
has_andthen : Type → Type
has_append : Type → Type
has_coe : Type → Type → Type
has_coe_t : Type → Type → Type
has_coe_to_fun : Type → Type
has_coe_to_sort : Type → Type
has_div : Type → Type
has_dvd : Type → Type
has_inv : Type → Type
has_le : Type → Type
has_lift : Type → Type → Type
has_lift_t : Type → Type → Type
has_lt : Type → Type
has_mod : Type → Type
has_mul : Type → Type
has_neg : Type → Type
has_one : Type → Type
has_ordering : Type → Type
has_sizeof : Type → Type
has_sub : Type → Type
has_to_format : Type → Type
has_to_pexpr : Type → Type
has_to_string : Type → Type
has_to_tactic_format : Type → Type
has_zero : Type → Type
inhabited : Type → Type
is_associative : Π {A}, (A → A → A) → Type₁
monad : (Type → Type) → Type
nonempty : Type → Prop
point : Type → Type → Type
setoid : Type → Type
subsingleton : Type → Prop
